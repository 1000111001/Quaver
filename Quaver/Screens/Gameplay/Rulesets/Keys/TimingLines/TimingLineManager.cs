using Quaver.API.Maps;
using System;
using System.Collections.Generic;
using System.Text;

namespace Quaver.Screens.Gameplay.Rulesets.Keys.TimingLines
{
    public class TimingLineManager
    {
        /// <summary>
        ///     Timing Line object pool.
        /// </summary>
        private List<TimingLineObject> Pool { get; set; }

        /// <summary>
        ///     Timing Line information. Generated by this class with qua object.
        /// </summary>
        private List<TimingLineInfo> Info { get; set; }

        /// <summary>
        ///     Reference to the ruleset this HitObject manager is for.
        /// </summary>
        public GameplayRulesetKeys Ruleset { get; }

        /// <summary>
        ///     The position at which the next TimingLine must be at in order to add a new TimingLine object to the pool.
        /// </summary>
        private float CreateObjectPosition { get; set; }

        /// <summary>
        ///     The position at which the earliest TimingLine object must be at before its recycled.
        /// </summary>
        private float RecycleObjectPosition { get; set; }

        /// <summary>
        ///     The Timing Line's Y-Offset. Is calculated by skin hit object element Y size and hit position.
        /// </summary>
        private float ObjectYOffset { get; set; }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="map"></param>
        /// <param name="ruleset"></param>
        public TimingLineManager(Qua map, GameplayRulesetKeys ruleset)
        {
            Ruleset = ruleset;
            GenerateTimingLineInfo(map);
        }

        private void GenerateTimingLineInfo(Qua map)
        {
            Info = new List<TimingLineInfo>();
            float songPos = 0;
            int index = 0;

            // set initial increment that will update songPos by 4 beat lengths
            // todo: use constant variables
            var increment = (4 * 60 * 1000) / map.TimingPoints[index].Bpm;
            while (songPos < map.Length)
            {
                // Update songpos with increment
                songPos += increment;

                // If songPos exceeds the next timing point (if next timing point exists):
                // Reset songPos to the next timing point and update increment
                // subtract Timing Point StartTime by 1 to add more tolerance when finding next Timing Point
                if (index + 1 < map.TimingPoints.Count && songPos >= map.TimingPoints[index + 1].StartTime - 1)
                {
                    index++;
                    songPos = map.TimingPoints[index].StartTime;
                    increment = (4 * 60 * 1000) / map.TimingPoints[index].Bpm;
                }

                var offset = Ruleset.Screen.Positioning.GetPositionFromTime(songPos);
                var info = new TimingLineInfo(songPos, offset);
                Info.Add(info);
            }
        }

        public void UpdateTimingLines()
        {

        }
    }
}
